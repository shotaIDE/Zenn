---
title: "ブランチ管理なんて人類には早かったのだ・・・トランクベース開発で複雑なブランチ管理とおさらば！"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ios", "android"]
published: false
---

# はじめに

複数のプロジェクトでトランクベース開発を推進してきました。

ただし、特にリリースの際の開発フローについて、プロジェクトによってカスタマイズする必要があります。

開発スピードが落ちないようにリリースの頻度が高められるようにすることを目指すため導入しました。

プロジェクトでトランクベース開発を実施しています。

1 年ほど運用してみて、どのようなメリット・デメリットがあるかをまとめました。

# 私のトランクベース開発の解釈

以下の 2 点を禁止することを目指します。

- 開発したコードをマージしてはいけない期間を設けない
- 大規模または長期にわたる開発をエンジニアの特定のメンバーだけで閉じて行わない

## 開発したコードをマージしてはいけない期間を設けない

これは、開発が中断することを防ぐためです。

## 大規模または長期にわたる開発をエンジニアの特定のメンバーだけで閉じて行わない

![長期、大規模な修正を特定のメンバーだけで行うのは悪い](/images/mobile-trunk-based-release-strategy/merge-large-changes.png)

これは以下の辛さがあるためです。

- 大規模な修正はセルフテストが十分に行えないことが多い
- 大規模な修正はコードレビューが十分に行えないことが多い
- 大規模な修正はコンフリクトが発生し、解消ミスを起こしやすい
- 大規模な修正は、バグ発生時の原因特定が難しい
- 大規模な修正は、特定のメンバーだけに確認が集中しやすく、他のメンバーの知見が活かされにくい

これは、**リリース用の生存期間が長いブランチを作り、最後にマージするという営みも行わな**いことを意味します。

- 開発ブランチからリリースブランチを分岐させ、受け入れ試験で発生したバグ修正をそこに適用し、最後に開発ブランチへマージする
  - このような戦略は、開発ブランチを触っているメンバーとリリースブランチを触っているメンバーが異なるため、コンフリクトが発生しやすい

Git-flow や一般的なブランチ管理戦略では、よくみられるものではあります。

![リリースブランチを作り、最後にマージする](/images/mobile-trunk-based-release-strategy/merge-release-branch.png)

そのため、小さな修正を頻繁に行い、全員が見えるところに公開していくことを目指します。

![小さな修正をこまめにマージする](/images/mobile-trunk-based-release-strategy/commit-on-only-trunk.png)

これがトランクベース開発です。

# 採用しているトランクベース開発の概要

## 普段の開発

![普段の開発](/images/mobile-trunk-based-release-strategy/development-flow.png)

Git で**トランクブランチ**という 1 つのブランチを据えます。

開発メンバーは必ずトランクブランチに対して PR を作成し、トランクブランチにマージします。

開発メンバーは開発作業において、トランクブランチの最新コミットから分岐させたブランチで PR を作成し、必ずトランクブランチにマージします。

**機能開発やバグ修正など種別に関わらず、また、ターゲットのリリースバージョンに関わらず、全てのコミットはトランクブランチにマージ**されます。

PR マージ時に Squash マージを採用しているため、最終的には **PR1 つにつきトランクブランチに 1 コミットが生成**されます。

## 定期リリース

定期リリースの際には以下のようなフローをたどります。

```mermaid
flowchart TD
    A[トランクブランチの最新コミット*からリリースブランチ作成] --> B[リリースブランチ上でアプリ作成し、テスト]
    B --> C{修正必須のバグが見つかったか？}
    C -->|Yes| D[トランクブランチに修正を適用]
    D --> E[リリースブランチに修正をコピー]
    E --> B
    C -->|No| F[リリース]
```

定期的なリリース時には、基本的にはトランクブランチの最新コミットからリリースブランチを分岐させます。

派生させたリリースブランチ上で初回ビルドします。

ビルドされたアプリに対しテストを行います。

バグが見つかれば、バグ修正をトランクブランチに適用します。
その後、そのバグ修正をリリースブランチに適用（チェリーピック）します。
その後、追加加ビルドを行います。

これをリリース可能な基準に達するまで繰り返し、最後のビルドをストアに審査をかけてリリースします。

### 初回ビルド

![1回目のブランチ戦略・弾くコミットがない場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_01.png)

基本的には**トランクブランチの最新コミットからリリースブランチを分岐**させます。

分岐させたブランチ上で初回ビルドを行います。

例外としては、以下のような理由により次のリリースに含みたくない修正がトランクブランチ上に適用されている場合、それを含まない形でリリースブランチを切ることがあります。

- リリース時のシステム全体へ与えるリスクが高く、その対策ができていない
- デグレを引き起こすことが明確に分かっている
- 後のリリースで提供したい機能である

![1回目のブランチ戦略・弾くコミットがある場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_02.png)

:::message
基本的には上記のように特定のコミットだけリリースに含めないということは避けるべきです。
これを避けるための手段として、以下があります。

- 開発の計画段階でシステム全体へのリスクを評価し、Ops トグルの導入前提で開発に着手する
- 開発の計画段階でリリース単位を検討し、リリーストグルの導入前提で開発に着手する

:::

このように 1 回目のビルドは、特に理由がなければトランクブランチの内容を最新まで全て含めるので、**包括的なかき集め**るフェーズと言えます。

### 2 回目以降のビルド

ビルドされたアプリでテストを行い、バグが見つかった場合には、**トランクブランチに修正を適用**します。

その後、トランクブランチ上の修正を**リリースブランチにチェリーピック**します。

![2回目以降のビルドのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_03.png)

:::message
チェリーピックとは、あるコミットを別のブランチに持っていく作業です。
:::

つまり、**リリースブランチ上でテストをしていますが、エンジニアはバグ修正をトランクブランチに適用**しています。

:::message
この辺りは一見奇妙に思われますが、以下のような考えに基づいています。

- リリースブランチとトランクブランチは大きく乖離していない前提なので、バグの再現性やバグ修正のベースとなるコードとして同一視して実用上問題ない
- エンジニアメンバーには複雑なブランチ管理をすることなく、バグ修正の内容だけに集中してほしい

1 項目目にある通り、トランクブランチとリリースブランチの乖離が大きければこの戦略は適用できないため、大きくならないよう開発フローを最適化していく必要があります。

![乖離が大きくなってはいけない](/images/mobile-trunk-based-release-strategy/diff-trunk-and-release.png)

また、バグ修正を適用した時点のトランクブランチのコミットで 2 回目以降のビルドを行うという選択肢もあります。
しかし、この方法は以下のデメリットがあるため採用していません。

- リリース前のテストでバグ修正後に修正して再テストする際、必要最小限の修正をしたい

:::

まとめると、2 回目以降のビルドは前回のビルドから取り込まれていないコミットを全て精査し、現在ターゲットとしているリリースに必ず含めたいもののみをチェリーピックしています。
必要なもの以外は取り込まないので、**排他的なかき集め**フェーズと言うことができます。

:::details そのほかの記述

- トランクブランチ上の開発を止めたくない
- リリースブランチは、トランクブランチにはマージしない

トランクブランチが正史であり、トランクブランチに修正します。
その上で、リリース時には、正史の特定の時点を切り出したものとなります。
ところが、特定の時点を切り出すとバグが発生しているという状況の場合、正史の一部分を継ぎ足すことで完成された歴史を作ります。

QA メンバーもトランクブランチ上でビルドされたアプリを使ってテストを行います。

この上で、トランクブランチの特定の時点で切り出してリリースするために必要なコミットをチェリーピックによりかき集めたものとします。

また、総合テストでバグがあまり見つからないことを前提としています。
バグが見つかりすぎると、リリースブランチがトランクブランチと乖離しすぎるため、トランクブランチで修正するのは難しくなってくるためです。

リリースブランチにマージしていくというスタイルは、GitLab-flow に含まれる戦略です。
ただ、フィーチャーブランチを許容していないという点で GitLab-flow とは異なります。

トランクベース開発は息の長いブランチを許容していません。
この息の長いブランチの禁則は、ブランチの分岐元と分岐先が独自にコミットを積み重ねていった結果、安全に統合することが難しくなるためです。
ここでリリースブランチが息の長いブランチになっていますが、リリースブランチはリリース直前に少しチェリーピックが発生するだけです。
そのため、安全に統合できると考え、現状許容しています。

:::

## hotfix リリース

前回のリリースブランチからリリースブランチを新たに作ります。
その後、hotfix として取り込むべき内容をトランクブランチから排他的に取り込みます。

![hotfixのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-hotfix-release.png)

# 参考

https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development?hl=ja
