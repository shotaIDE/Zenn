---
title: "私のモバイルプロジェクトにおけるトランクベース開発によるリリース戦略"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ios", "android"]
published: false
---

# 目指したいこと

## こまめにデプロイ

大規模な修正を特定のメンバーが自分の手元だけで行わないことを目指します。

![](/images/mobile-trunk-based-release-strategy/merge-changes-to-trunk-branch_bad-pattern.png)

これは以下のリスクがあるためです。

- 大規模な修正はセルフテストが十分に行えないことが多い
- 大規模な修正はコードレビューが十分に行えないことが多い
- 大規模な修正はコンフリクトが発生し、解消ミスを起こしやすい
- 大規模な修正は、バグ発生時の原因特定が難しい
- 大規模な修正は、特定のメンバーだけに確認が集中しやすく、他のメンバーの知見が活かされにくい

そのため、小さな修正を頻繁に行い、全員が見えるところに公開していくことを目指します。

![](/images/mobile-trunk-based-release-strategy/merge-changes-to-trunk-branch_good-pattern.png)

## マージをブロックする要素を減らす

また、マージをブロックする要素を減らすことを目指します。

これがトランクベース開発です。

# 採用しているトランクベース開発の概要

## 普段の開発

![トランクベース開発の概念図](/images/mobile-trunk-based-release-strategy/trunk-based-flow-for-project.png)

Git でトランクブランチという 1 つのブランチを据えます。

開発メンバーは必ずトランクブランチに対して PR を作成し、トランクブランチにマージします。

開発メンバーは開発作業において、トランクブランチの最新コミットから分岐させたブランチで PR を作成し、必ずトランクブランチにマージします。

機能開発やバグ修正など種別に関わらず、また、ターゲットのマイルストーンに関わらず、全てのコミットはトランクブランチにマージされます。

## 定期リリース

リリース時には、トランクブランチの特定の時点でリリースブランチを切り出します。

初回ビルドした後、リリース前のテストを行い、バグが見つかれば、バグ修正を取り込んだ追加ビルドを行います。

### 初回ビルド

![](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_01.png)

リリース作業時に、基本的にはトランクブランチの最新コミットからリリースブランチを分岐させます。

基本的にはトランクブランチの内容が全て含まれることになるので、包含的なかき集めということができます。

例外としては、以下のような修正が最新の方に来ている場合に、それを含まない形でリリースブランチを切ることがあります。

- 次のリリースに含みたくない修正

![](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_02.png)

リリースブランチ上でアプリをビルド・デプロイし、リリース前のテストを行います。

### 2 回目以降のビルド

バグが見つかった場合には、**トランクブランチに修正を適用**します。

その後、トランクブランチ上の修正を**リリースブランチにチェリーピック**します。

![](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_03.png)

初回ビルドから取り込まれていないコミットを全て精査し、現在ターゲットとしているリリースに必ず含めたいもののみをチェリーピックしていきます。
必要なもの以外は取り込まないので、排他的なかき集めということができます。

:::message
チェリーピックとは、あるコミットを別のブランチに持っていく作業です。
:::

この辺りは、奇妙に思われますが、以下のような考えに基づいています。

- リリースブランチとトランクブランチは大きく乖離していない前提なので、バグの再現性やバグ修正適用時の再利用性で違いがない
- リリース前のテストでバグ修正後に修正して再テストする際、必要最小限の修正をしたい
- トランクブランチ上の開発を止めたくない
- リリースブランチは、トランクブランチにはマージしない

トランクブランチとリリースブランチの乖離はそこまで大きくないことを根拠にしています。
トランクブランチとリリースブランチの乖離が大きければこの戦略は適用できないため、大きくならないよう開発フローを最適化していく必要があります。

トランクブランチが正史であり、トランクブランチに修正します。
その上で、リリース時には、正史の特定の時点を切り出したものとなります。
ところが、特定の時点を切り出すとバグが発生しているという状況の場合、正史の一部分を継ぎ足すことで完成された歴史を作ります。

QA メンバーもトランクブランチ上でビルドされたアプリを使ってテストを行います。

この上で、トランクブランチの特定の時点で切り出してリリースするために必要なコミットをチェリーピックによりかき集めたものとします。

また、総合テストでバグがあまり見つからないことを前提としています。
バグが見つかりすぎると、リリースブランチがトランクブランチと乖離しすぎるため、トランクブランチで修正するのは難しくなってくるためです。

リリースブランチにマージしていくというスタイルは、GitLab-flow に含まれる戦略です。
ただ、フィーチャーブランチを許容していないという点で GitLab-flow とは異なります。

トランクベース開発は息の長いブランチを許容していません。
この息の長いブランチの禁則は、ブランチの分岐元と分岐先が独自にコミットを積み重ねていった結果、安全に統合することが難しくなるためです。
ここでリリースブランチが息の長いブランチになっていますが、リリースブランチはリリース直前に少しチェリーピックが発生するだけです。
そのため、安全に統合できると考え、現状許容しています。

## hotfix リリース

前回のリリースブランチからリリースブランチを新たに作ります。
その後、hotfix として取り込むべき内容をトランクブランチから排他的に取り込みます。

![](/images/mobile-trunk-based-release-strategy/trunk-based-hotfix-release.png)

# はじめに

プロジェクトでトランクベース開発を実施しています。

https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development?hl=ja

1 年ほど運用してみて、どのようなメリット・デメリットがあるかをまとめました。

# 導入背景

リリースにおけるリスクやコストを最小化し、リリースの頻度が高められるようにすることを目指すため導入しました。

# メリット

トランクブランチ開発は、生存期間の長いブランチを許容しないことが最大の特徴です。
その点が異なる Git-flow や GitLab-flow、GitHub-flow などのブランチ戦略と比較した、メリット・デメリットを記載します。

## 開発メンバーが実施しなければならないブランチ管理が限りなく簡単になる

- ブランチ管理やコンフリクト対応、マージ対応などを全てのメンバーが行うには、ハードルが高いため
- ブランチ管理にコストを取られ、価値提供にコストを使えなくなるのを防ぎたいため
- コンフリクトが少なくなる

長大なブランチ管理のための手順書を覚える必要がない。

## 1 本のブランチ上で開発、テスト、自動チェック(CI)を集中することで、これらのコストパフォーマンスを最大化できる

- CI の価値を最大化するため
- 定期的な自動・手動リグレッションテストのコストを最小にしつつ、価値を最大化するため
- 開発者・QA が同じブランチを触る・検証する
- トランクブランチが壊れた場合にすぐに気づきやすく、復元時間を最短にできる。

## 副次的な効果として、フィーチャーフラグによりリリースの柔軟性やベータテストの柔軟性が高まる

- リモートで管理することにより、切り戻しの範囲を柔軟に設定でき、切り戻しの所要時間を最小化できる
- 範囲や段階を柔軟に設定したカナリアリリースができる
- アプリ内で管理することにより、アーリーアクセス機能としてのリリースができる
  - ユーザーによるフィードバックを得ることができる

## チームがスケールしやすい

# デメリット

## 開発メンバーにとってのメリットが大きいため、力関係によっては導入しにくい

## フィーチャーフラグの導入により、開発プロセス全体で少しずつ複雑性が増す

- 一時的に分岐が発生することにより、コードの複雑さが増す
- サイレントリリースすることにより、デプロイや監視のオペレーションパターンが増える
- フィーチャーフラグを外すことを将来行う必要がある

## フィーチャーフラグはブランチ管理よりも理解されていないことが多いため、プロジェクトメンバーの学習コストが発生しやすい

- プロダクトオーナー、QA など関係者すべてに周知し、キャッチアップしてもらう必要がある

## 良くも悪くも、受け入れ基準やリリース対象などとは関係なくまぜこぜに修正が取り込まれていく

### 細かいバグ修正や改善に関して、開発時期と独立してリリースに取り込みたい内容を取捨選択するのが難しくなる

トランクブランチに全てのコミットをマージしていくため、フィーチャーフラグなどで管理しているような機能は問題ないです。
ただ、細かいバグ対応なども全てフィーチャーフラグなどで管理することは現実的でないです。

リリースの際にはトランクブランチの特定の時点でリリースビルドを行うため、こうした細かいバグ対応を入れないということが難しくなります。

ただ、そもそも実装したのにリリースに入れない、ということは、長い時間マージされないブランチやコミットが存在することになります。
これは管理やマージ時のリスクを考えるとそもそも避けたいことです。

そのため、細かいバグ対応は、順次リリースに入れていくということをプロダクトオーナーと握っておくのが良いでしょう。

### そもそもなぜ長い時間マージされないブランチやコミットが存在すると、リスクが高まるのか

コード修正は、「元々のコード状態」を踏まえた上で修正を加える、という営みです。

開発は日々進んでいくため、マージする対象のコードは日々変わっていきます。
つまり「元々のコード状態」が日々変わっていくため、時間が経つにつれ修正の加え方を再検討する必要が生じてきます。

そのため、元々のコード状態が変わってしまうと、修正を加える際に元々のコード状態を踏まえた上で修正を加える、ということが難しくなります。

Git は親コミットに対して差分を適用していく構造になっている。
そのため、コミット 1→ コミット 2→ コミット 3 という順番で並んでいた時に、コミット 1→ コミット 3 という順番で並び替えるためにはチェリーピックが必要となる。

チェリーピックはマージと異なり、コミット 3 の差分をコミット 1 の子として新しく作り直すという作業になる。
そのため、元々のコミット 3 とは別のハッシュ値を持つコミット 3 ができる。

# 導入の前提みたいなもの

## リリース頻度が高い

## QA チームと開発チームが密に連携している

テスト期間が長すぎると適していないと考えられる。

## リリース担当者を立てられる

開発内容もわかりつつ、リリース作業を行う人が必要。

チェリーピックなどの作業が発生するため、Git の操作や概念に慣れている人が望ましい。

# メリットとデメリットの比較

Git-flow などのブランチ戦略に比べて、トランクベース開発によるリリース戦略は以下のような特徴があります。

開発中の機能もフィーチャーフラグなどを利用してトランクブランチにマージされていきます。
これにより、全ての開発メンバーがビルドし修正するコードに早期統合されるため、設計の破綻やコードの不都合を早期に発見しやすくなります。

全ての開発メンバーで 1 つのコードを共有し、全ての QA メンバーで 1 つのアプリを検証することになります。

リリース前のタイミングで統合するよりも、早いタイミングで統合していくことで、統合の痛みを分散させていくという取り組みとも言えます。

このように考えることで、リリースの頻度を高めることができます。

コード中の分岐の扱いを間違えるというミスよりもブランチ管理を間違えるというミスの方が体感としては発生しやすいです。

これらを踏まえ、将来的に目指す方向性と合っていると考えて、採用し運用中です。

ブランチ管理の方が、ブランチ管理のためのコストが高いです。

# 運用上必要になってくること

## 作ったものはすぐにリリースしましょうという方向で握る

## 1 件 1 件の PR に対して、完璧にしてからマージするという戦略は取らない

## トランクブランチのいつでもある程度致命的なバグが存在しない状態の水準にする

### デグレを検知した場合は、早急に対応する

1 つのチケットを 1 つの PR で対応できればいいが、そうできない場合も発生する。
その際は、一定期間(2 週間程度)より長く滞留してしまったら、以下のいずれかの方針をとる。

1. 対応した PR により機能のデグレーションが発生している
   - 一旦トランクブランチ上でリバートし、再着手時に再度 PR を立てる
2. 対応した PR により機能のデグレーションが発生していないものの、チケットに記載しているバグが完全には解消していない
   - PR をリリースする。チケットに`記載時点までのPRをリリース可能`という日付フィールドに、判断した日付を入力する。
3. 対応した PR により機能のデグレーションは発生しておらず、チケットに記載しているバグが解消している一方で、別のバグが見つかっている
   - チケットを完了としてリリースまで持っていき、別のバグは別チケットで管理する。

品質を担保した後にマージというフェーズが取らないため。

## 開発単位をできるだけ小さく保つ

チェリーピックする際にコンフリクトが発生する可能性を下げる。
複数のコミットが同時多発的に一本のブランチにマージされていくので、何か問題が発生した時に、切り分けができるように。

## フィーチャーフラグやビルドツールの活用によりマージとリリースを分離する

開発中の中途半端な機能もフィーチャーフラグを用いて一般には公開されない状態にしつつ、リリースできる状態とする。

## Squash マージを強制し、PR1 つに対し 1 つのコミットが生成されるようにする

GitHub の設定を変更し、Squash マージとする。
これは、最終的にメインブランチに PR のタイトルがコミットメッセージとされたコミット履歴を残し、コミットごとにリリース計画を立てやすくするため。
また、PR ごとの細かいコミットに気を使うのはコストもかかるし、自然とできるメンバーも少ないので、細かいコミットを捨てるため。

## やっぱりこの機能まだリリースしたくないとなった場合

トランクブランチに対して、フィーチャーフラグを用いてリリース対象外とする修正を適用する。
その後、リリースブランチにチェリーピックする。
