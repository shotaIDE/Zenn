---
title: "ブランチ管理なんて人類には早かったのだ・・・トランクベース開発で複雑なブランチ管理とおさらば！"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ios", "android"]
published: false
---

# はじめに

複数のプロジェクトで**トランクベース開発**を推進してきました。

ただし、特にリリースの際の開発フローについて、プロジェクトによってカスタマイズする必要があります。

開発スピードが落ちないようにリリースの頻度が高められるようにすることを目指すため導入しました。

プロジェクトでトランクベース開発を実施しています。

1 年ほど運用してみて、どのようなメリット・デメリットがあるかをまとめました。

# 私のトランクベース開発の解釈

## やってはいけないこと

以下の 2 点を禁止することを目指します。

- 開発したコードをマージしてはいけない期間を設けない
- 大規模または長期にわたる開発をエンジニアの特定のメンバーだけで閉じて行わない

### 開発したコードをマージしてはいけない期間を設けない

これは、開発が中断することを防ぐためです。

### 大規模または長期にわたる開発をエンジニアの特定のメンバーだけで閉じて行わない

![長期、大規模な修正を特定のメンバーだけで行うのは悪い](/images/mobile-trunk-based-release-strategy/merge-large-changes.png)

これは以下の辛さがあるためです。

- 大規模な修正はセルフテストが十分に行えないことが多い
- 大規模な修正はコードレビューが十分に行えないことが多い
- 大規模な修正はコンフリクトが発生し、解消ミスを起こしやすい
- 大規模な修正は、バグ発生時の原因特定が難しい
- 大規模な修正は、特定のメンバーだけに確認が集中しやすく、他のメンバーの知見が活かされにくい

これは、**リリース用の生存期間が長いブランチを作り、最後にマージするという営みも行わな**いことを意味します。

- 開発ブランチからリリースブランチを分岐させ、受け入れ試験で発生したバグ修正をそこに適用し、最後に開発ブランチへマージする
  - このような戦略は、開発ブランチを触っているメンバーとリリースブランチを触っているメンバーが異なるため、コンフリクトが発生しやすい

Git-flow や一般的なブランチ管理戦略では、よくみられるものではあります。

![リリースブランチを作り、最後にマージする](/images/mobile-trunk-based-release-strategy/merge-release-branch.png)

## 目指す方向

そのため、小さな修正を頻繁に行い、全員が見えるところに公開していくことを目指します。

![小さな修正をこまめにマージする](/images/mobile-trunk-based-release-strategy/commit-on-only-trunk.png)

これがトランクベース開発です。

# 採用しているトランクベース開発の概要

## 普段の開発

![普段の開発](/images/mobile-trunk-based-release-strategy/development-flow.png)

Git で**トランクブランチ**という 1 つのブランチを据えます。

開発メンバーは必ずトランクブランチに対して PR を作成し、トランクブランチにマージします。

開発メンバーは開発作業において、トランクブランチの最新コミットから分岐させたブランチで PR を作成し、必ずトランクブランチにマージします。

**機能開発やバグ修正など種別に関わらず、また、ターゲットのリリースバージョンに関わらず、全てのコミットはトランクブランチにマージ**されます。

PR マージ時に Squash マージを採用しているため、最終的には **PR1 つにつきトランクブランチに 1 コミットが生成**されます。

## 定期リリース

定期リリースの際には以下のようなフローをたどります。

```mermaid
flowchart TD
    A[トランクブランチの最新コミット*からリリースブランチ作成] --> B[リリースブランチ上でアプリ作成し、テスト]
    B --> C{修正必須のバグが見つかったか？}
    C -->|Yes| D[トランクブランチに修正を適用]
    D --> E[リリースブランチに修正をコピー]
    E --> B
    C -->|No| F[リリース]
```

定期的なリリース時には、基本的にはトランクブランチの最新コミットからリリースブランチを分岐させます。

派生させたリリースブランチ上で初回ビルドします。

ビルドされたアプリに対しテストを行います。

バグが見つかれば、バグ修正をトランクブランチに適用します。
その後、そのバグ修正をリリースブランチに適用（チェリーピック）します。
その後、追加加ビルドを行います。

これをリリース可能な基準に達するまで繰り返し、最後のビルドをストアに審査をかけてリリースします。

リリース後には、**リリースブランチはトランクブランチにはマージしません**。

### 初回ビルド

![1回目のブランチ戦略・弾くコミットがない場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_01.png)

基本的には**トランクブランチの最新コミットからリリースブランチを分岐**させます。
分岐させたブランチ上で初回ビルドを行います。

例外としては、以下のような理由により**次のリリースに含みたくない修正がトランクブランチ上に適用されている**場合、それを含まない形でリリースブランチを切ることがあります。

- リリース時のシステム全体へ与えるリスクが高く、その対策ができていない
- デグレを引き起こすことが明確に分かっている
- 後のリリースで提供したい機能である

![1回目のブランチ戦略・弾くコミットがある場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_02.png)

:::message
基本的には上記のように特定のコミットだけリリースに含めないということは、後述する理由で避けるべきです。
これを避けるための手段として、開発の計画段階でシステム全体へのリスクやリリース単位を検討しておき、必要に応じてフィーチャートグル（リリーストグルや Ops トグル）を導入する方法があります。
:::

このように 1 回目のビルドは、特に理由がなければトランクブランチの内容を最新まで全て含めるので、**包括的なかき集め**フェーズと捉えることができます。

### 2 回目以降のビルド

![2回目以降のビルドのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_03.png)

ビルドされたアプリでテストを行い、バグが見つかった場合には**トランクブランチに修正を適用**します。

その後、トランクブランチ上の修正を**リリースブランチにチェリーピックにより適用**します。

:::message
チェリーピックとは、修正内容を別のブランチに対して再適用する作業です。通常は Git の機能により機械的に行えます。
:::

つまり、**リリースブランチ上でテストしている一方で、バグ修正時にはエンジニアはまずトランクブランチで調査と修正をしています**。

テストするブランチとコードを調査・修正するブランチが一致していないのは一見奇妙に思われますが、以下のような考えに基づいています。

- **リリースブランチとトランクブランチは大きく乖離していない前提**なので、バグの再現性やバグ修正のベースとなるコードとして同一視して実用上問題ない
- リリースブランチを担当するメンバー以外は複雑なブランチ管理をすることなく、バグ修正の内容だけに集中してほしい

トランクブランチとリリースブランチの乖離が大きいと上記の戦略は破綻するため、以下の図に示すような乖離部分が大きくならないよう開発フローや品質を最適化していく必要があります。

![乖離が大きくなってはいけない](/images/mobile-trunk-based-release-strategy/diff-trunk-and-release.png)

:::message
バグ修正を適用した時点のトランクブランチのコミットで 2 回目以降のビルドを行うという選択肢もあります。
しかし、この方法ではトランクブランチにリリースのバグ対応以外の修正が含まれてしまう可能性があり、追加でテストすべき範囲が広がってしまうため採用していません。
:::

以上をまとめると、2 回目以降のビルドは前回のビルドから取り込まれていないコミットを全て精査し、現在ターゲットとしているリリースに必ず含めたいもののみをチェリーピックしています。
必要なもの以外は取り込まないので、**排他的なかき集め**フェーズと捉えることができます。

:::details そのほかの記述

- トランクブランチ上の開発を止めたくない
- リリースブランチは、トランクブランチにはマージしない

トランクブランチが正史であり、トランクブランチに修正します。
その上で、リリース時には、正史の特定の時点を切り出したものとなります。
ところが、特定の時点を切り出すとバグが発生しているという状況の場合、正史の一部分を継ぎ足すことで完成された歴史を作ります。

QA メンバーもトランクブランチ上でビルドされたアプリを使ってテストを行います。

この上で、トランクブランチの特定の時点で切り出してリリースするために必要なコミットをチェリーピックによりかき集めたものとします。

また、総合テストでバグがあまり見つからないことを前提としています。
バグが見つかりすぎると、リリースブランチがトランクブランチと乖離しすぎるため、トランクブランチで修正するのは難しくなってくるためです。

リリースブランチにマージしていくというスタイルは、GitLab-flow に含まれる戦略です。
ただ、フィーチャーブランチを許容していないという点で GitLab-flow とは異なります。

トランクベース開発は息の長いブランチを許容していません。
この息の長いブランチの禁則は、ブランチの分岐元と分岐先が独自にコミットを積み重ねていった結果、安全に統合することが難しくなるためです。
ここでリリースブランチが息の長いブランチになっていますが、リリースブランチはリリース直前に少しチェリーピックが発生するだけです。
そのため、安全に統合できると考え、現状許容しています。

:::

## hotfix リリース

**前回のリリースブランチからリリースブランチを新たに作ります**。

その後、hotfix として取り込むべき内容を**トランクブランチから排他的にかき集めて**、ビルドします。

![hotfixのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-hotfix-release.png)

# 参考

https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development?hl=ja
